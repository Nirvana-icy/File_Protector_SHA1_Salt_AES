File_Protector_SHA1_Salt_AES
============================
	实现原理：
该应用程序的编写思路简明叙述如下：在文件浏览的基础上选定需要加密/解密的文件，之后得到用户输入的密码，调用密钥生成模块生成AES加密/解密密钥。之后循环读出文件的内容并使用生成的密钥对文件内容块进行加密/解密运算。再将加密/解密运算后的数据块写回文件。
程序的核心部分就是密钥生成和数据加密/解密运算部分。



下面就详细介绍一下这两个部分：

	Void GeneralKey(TDesC16& aKey, TDesC8& gKey)
密钥生成流程:
a.	得到用户输入的口令。
b.	将16位的Unicode编码的口令转化为8位的ASCII编码的口令。
c.	由该口令和程序中预先定义的两个字符串(作为盐),按一定规则构造一个待摘要的字符串。
d.	对该字符串使用SHA1算法进行数据摘要,产生160位的摘要结果。
e.	取该摘要结果的前128位作为AES算法的密钥。  
构造待摘要字符串的规则:
ASCII编码的口令+第一个程序预先定义的字符串+ASCII编码的口令+第二个程序预先定义的字符串+ASCII编码的口令。
待摘要字符串组成分析:
该字符串由ASCII编码的口令和两把“盐”构成。ASCII编码的口令使用了三次,两把“盐”各使用了一次。ASCII编码的口令的长度为80位。交叉使用了三次,共240位。第一把“盐”的长度是88位,第二把“盐”的长度是40位。
总计368位的待摘要数据,一个SHA1分组即可处理该待摘要数据。这一点主要考虑到了该应用程序运行的平台属于资源受限平台。由用户输入的Unicode编码的口令转为ASCII编码的口令,这一过程不仅为使用以字节为单位的密码算法做准备还有对用户输入口令变换的作用。ASCII编码的口令的长度占整个带摘要字符串长度的65.22%,并交叉在两把“盐”的左右。这就决定了由用户输入的口令对摘要值的产生起主要作用但不是绝对作用。另一方面,由于攻击者在不知道盐的具体值和待摘要数据的组成规则。可以在一定程度的避免攻击者利用编程方法实现对AES密钥算法的自动穷举攻击。


	void DoEncryption(TDesC16& aKey, TDesC& aPath, TInt& aIndex)
实现思路为：
循环读出文件内容到缓冲区。针对缓冲区中的数据进行AES加密运算，之后直接就地将加密后的密文数据块写回文件中原来明文数据块的位置。
由于采用了密文就地覆盖原明文的方法，这样可以避免攻击者使用磁盘恢复工具	将原文件恢复出来。
这个模块中的AES加密算法是由Symbian附加的密码算法库支持。File Protector中使用的AES的具体情况为，密钥取值128位，数据块大小128位。针对循环读取文件的最后一块可能不足128位，采取填充0的方法使其达到128位的分组长度。这样在加密后，文件的大小会有小于128位的增长。在解密时程序去掉填充的字符，文件的长度恢复原值。
